# リソース管理

Skijaは、C++のSkiaライブラリをJavaでラップしたものです。つまり、多くのJavaオブジェクトはネイティブC++リソースによって支えられています。これらのリソースがどのように管理されるかを理解することは、安定した効率的なアプリケーションを構築するために重要です。

## 自動メモリ管理

デフォルトでは、Skijaはメモリを自動的に管理します。ほとんどのSkijaオブジェクトは`Managed`クラスを継承しています。Javaオブジェクトがガベージコレクションされると、Skijaは対応するネイティブC++リソースも解放されるようにします。

```java
void drawSomething(Canvas canvas) {
    Paint paint = new Paint(); // ネイティブリソースが割り当てられる
    canvas.drawCircle(50, 50, 20, paint);
} // paintがスコープ外になり、GCによって最終的にクリーンアップされる
```

ほとんどのユースケースでは、この「デフォルトで安全」な動作がまさに求められるものです。

## 手動リソース解放

パフォーマンスが重要なアプリケーションや、多くの短命オブジェクトを扱う場合、ガベージコレクタを待つよりも、ネイティブリソースを即座に解放したい場合があります。

すべての`Managed`オブジェクトは`AutoCloseable`を実装しているため、`try-with-resources`パターンを使用できます：

```java
void drawCircle(Canvas canvas) {
    try (Paint p = new Paint()) {
        canvas.drawCircle(50, 50, 20, p);
    } // ネイティブリソースはここで即座に解放される
}
```

**警告:** オブジェクトが閉じられると、再度使用することはできません。閉じられたオブジェクトを使用しようとすると、例外やクラッシュが発生します。

## オブジェクトの再利用

ネイティブオブジェクトの作成にはある程度のオーバーヘッドがあるため、特にレンダリングループでは、オブジェクトを再利用することが望ましい場合があります。

```java
class MyApp {
    private final Paint paint = new Paint().setColor(0xFFFF0000);

    void onRender(Canvas canvas) {
        canvas.drawCircle(100, 100, 50, paint); // 同じpaintオブジェクトを再利用
    }
}
```

## カプセル化とゲッター

Skijaは、データクラス（`Rect`、`Color4f`など）に対して特定の規約を使用しています。アンダースコアで始まるパブリックフィールド（例：`Color4f`の`_r`、`_g`、`_b`）をよく目にします。

**規約:**
- `_`で始まるフィールドは、**プライベート/内部**として扱うべきです。
- パブリックAPIへのアクセスには、必ず提供されている**ゲッター**（例：`getR()`、`getG()`）を使用してください。

```java
Color4f color = new Color4f(1f, 0f, 0f);

float r = color._r;    // 避けるべき: 内部フィールドへの直接アクセス
float r2 = color.getR(); // 推奨: パブリックゲッターの使用
```

このアプローチにより、将来のバージョンでこれらのデータクラスの内部実装が変更された場合でも、Skijaは安定したAPIを維持することができます。